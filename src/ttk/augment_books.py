# - utf-8 -
# -*- coding: utf-8 -*-
import os
import argparse
import logging
import traceback
from typing import List
import shutil

from ttk.llm_processing.add_chapter_answers import add_chapter_answers_to_questions
from ttk.llm_processing.add_chapter_questions import add_chapter_questions
from ttk.llm_processing.add_chapter_summaries import add_chapter_summaries
from ttk.llm_processing.add_chunk_answers import add_chunk_answers_to_questions
from ttk.llm_processing.add_categories import add_categories
from ttk.llm_processing.add_chunk_questions import add_chunk_questions
from ttk.llm_processing.add_chunk_summaries import add_chunk_summaries
from ttk.external_config_loader import load_external_config_from_file_exec
from ttk.llm_processing.remove_llm_request import remove_llm_requests_from_json
from ttk.models.text_models import BookModel
from ttk.utils import setup_logging


def consolidate_sums_and_cats(book: BookModel):
    book.build_category_from_chapters()


def process_book(file_path, config, action_function, consolidate=False) -> BookModel:
    """
    Process a single book file, applying the specified action function to it.

    :param file_path: The path to the book file.
    :param config: The configuration object to be used by the action function.
    :param action_function: The function that will perform the action on the book.
                            This function must accept 'book', 'config', and 'file_path' as arguments.
    :param consolidate: Consolidate the summaries and categories for chapters and the whole book
    """
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            book_json = f.read()
        book_model = BookModel.model_validate_json(book_json)
        action_function(book=book_model, config=config, file_path=file_path, save_to_file=True)
        if consolidate is True:
            consolidate_sums_and_cats(book_model)
        with open(file_path, "w", encoding="utf-8") as f:
            book_json = book_model.model_dump_json(indent=4)
            f.write(book_json)
        return book_model
    except Exception as e:
        message = f"Failed to process {file_path}: {e}"
        logging.error(message)
        logging.error(traceback.format_exc())
        print(message, traceback.format_exc())


def rotate_backup_files(file_path, backup_dir, max_backups=10):
    """
    Rotates the backup files, keeping only a specified number of backups.

    :param file_path: The path of the original file.
    :param backup_dir: The directory where backups are stored.
    :param max_backups: The maximum number of backups to keep, by default 10.
    """
    base_name = os.path.basename(file_path)
    backup_base_path = os.path.join(backup_dir, base_name)

    # Rotate existing backup files
    for i in range(max_backups - 1, 0, -1):
        src = f"{backup_base_path}.{i}"
        dst = f"{backup_base_path}.{i + 1}"
        if os.path.exists(src):
            if i == max_backups - 1:
                os.remove(src)  # Remove the oldest backup
            else:
                os.rename(src, dst)  # Shift backup files

    # Create the first backup file
    first_backup = f"{backup_base_path}.1"
    shutil.copy2(file_path, first_backup)


def walk_directory(directory, config, action_function, consolidate=False) -> List[BookModel]:
    """
    Walk through the directory, processing each book file found.

    :param directory: The directory to walk through.
    :param config: The configuration object to be used by the action function.
    :param action_function: The function that will perform the action on each book.
                            This function must accept 'book', 'config', and 'file_path' as arguments.
    :param consolidate: Consolidate the summaries and categories for chapters and the whole book
    """
    book_model_list = []
    backup_dir = os.path.join(directory, "backup")

    # Create the backup directory if it doesn't exist
    if not os.path.exists(backup_dir):
        os.makedirs(backup_dir)

    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith('.json'):  # JSON files are the target
                file_path = os.path.join(root, file)
                logging.info(f"Processing {file_path}")

                # Create a backup before processing
                rotate_backup_files(file_path, backup_dir)

                # Process the book file
                book_model = process_book(file_path, config, action_function, consolidate)
                if book_model:
                    book_model_list.append(book_model)

    return book_model_list


def main():
    """Script generated by poetry
    add_sum_quest = "ttk.augment_books:main"
    add_key_topics = "ttk.augment_books:main"
    add_answers = "ttk.augment_books:main"
    """
    setup_logging()
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest='command')

    parser_summary = subparsers.add_parser('add_chunk_summaries', help="Augment the provided JSON book files in a "
                                                                       "directory with summaries using an LLM "
                                                                       "for each chunk of the book.")
    parser_summary.add_argument("--input_dir", help="The directory with JSON books.")
    parser_summary.add_argument("--config", help="The configuration that should be used to create the summaries.")

    parser_chapter_summary = subparsers.add_parser('add_chapter_summaries',
                                                   help="Augment the provided JSON book files in a "
                                                        "directory with summaries using an LLM "
                                                        "for each chapter of the book.")
    parser_chapter_summary.add_argument("--input_dir", help="The directory with JSON books.")
    parser_chapter_summary.add_argument("--config",
                                        help="The configuration that should be used to create the summaries.")

    parser_questions = subparsers.add_parser('add_chunk_questions', help="Augment the provided JSON book files in a "
                                                                         "directory with questions using an LLM "
                                                                         "for each chunk of the book.")
    parser_questions.add_argument("--input_dir", help="The directory with JSON books.")
    parser_questions.add_argument("--config", help="The configuration that should be used to create the questions.")

    parser_chapter_questions = subparsers.add_parser('add_chapter_questions',
                                                     help="Augment the provided JSON book files in a "
                                                          "directory with questions using an LLM "
                                                          "for each chapter of the book.")
    parser_chapter_questions.add_argument("--input_dir", help="The directory with JSON books.")
    parser_chapter_questions.add_argument("--config",
                                          help="The configuration that should be used to create the questions.")

    parser_answers = subparsers.add_parser('add_chunk_answers', help="Augment the provided JSON book files in a "
                                                                     "directory with answers to the previous generated "
                                                                     "questions for chunks using an LLM.")
    parser_answers.add_argument("--input_dir", help="The directory with JSON books.")
    parser_answers.add_argument("--config", help="The configuration that should be used to create the answers.")

    parser_chapter_answers = subparsers.add_parser('add_chapter_answers',
                                                   help="Augment the provided JSON book files in a "
                                                        "directory with answers to the previous generated "
                                                        "questions for chapters using an LLM.")
    parser_chapter_answers.add_argument("--input_dir", help="The directory with JSON books.")
    parser_chapter_answers.add_argument("--config", help="The configuration that should be used to create the answers.")

    parser_categories = subparsers.add_parser('add_categories', help="Augment the provided JSON book files "
                                                                     "in a directory with keywords and topics "
                                                                     "using an LLM.")
    parser_categories.add_argument("--input_dir", help="The directory with JSON books.")
    parser_categories.add_argument("--config", help="The configuration that should be used "
                                                    "to create the keywords and topics data using an LLM.")

    parser_llm_requ = subparsers.add_parser('remove_llm_request', help="Remove the LLM request text from the "
                                                                       "json files.")
    parser_llm_requ.add_argument("--input_dir", help="The directory with JSON books.")

    args = parser.parse_args()

    if args.command == 'add_chunk_summaries':
        print("Add summaries")
        config = load_external_config_from_file_exec(args.config)
        walk_directory(args.input_dir, config, add_chunk_summaries, consolidate=False)
    elif args.command == 'add_chapter_summaries':
        print("Add chapter summaries")
        config = load_external_config_from_file_exec(args.config)
        walk_directory(args.input_dir, config, add_chapter_summaries, consolidate=False)
    elif args.command == 'remove_llm_request':
        print("Remove LLM requests")
        walk_directory(args.input_dir, None, remove_llm_requests_from_json, consolidate=False)
    elif args.command == 'add_chunk_questions':
        config = load_external_config_from_file_exec(args.config)
        book_model_list = walk_directory(args.input_dir, config, add_chunk_questions, consolidate=False)
        for book_model in book_model_list:
            print(f"Book :: {book_model.book_title} :: Generated number of questions: ", book_model.count_questions())
    elif args.command == 'add_chapter_questions':
        config = load_external_config_from_file_exec(args.config)
        book_model_list = walk_directory(args.input_dir, config, add_chapter_questions, consolidate=False)
        for book_model in book_model_list:
            print(f"Book :: {book_model.book_title} :: Generated number of questions: ", book_model.count_questions())
    elif args.command == 'add_chunk_answers':
        config = load_external_config_from_file_exec(args.config)
        book_model_list = walk_directory(args.input_dir, config, add_chunk_answers_to_questions, consolidate=False)
        for book_model in book_model_list:
            print(f"Book :: {book_model.book_title} :: Generated number of answers: ", book_model.count_questions())
    elif args.command == 'add_chapter_answers':
        config = load_external_config_from_file_exec(args.config)
        book_model_list = walk_directory(args.input_dir, config, add_chapter_answers_to_questions, consolidate=False)
        for book_model in book_model_list:
            print(f"Book :: {book_model.book_title} :: Generated number of answers: ", book_model.count_questions())
    elif args.command == 'add_categories':
        config = load_external_config_from_file_exec(args.config)
        book_model_list = walk_directory(args.input_dir, config, add_categories, consolidate=True)
        for book_model in book_model_list:
            if book_model and book_model.category:
                print(f"Book :: {book_model.book_title} :: Total number of categories",
                      len(book_model.category.categories))
                print(f"Book :: {book_model.book_title} :: Total number of keywords", len(book_model.category.keywords))
                print(f"Book :: {book_model.book_title} :: Total number of persons", len(book_model.category.persons))
                print(f"Book :: {book_model.book_title} :: Total number of places", len(book_model.category.places))
                print(f"Book :: {book_model.book_title} :: Total number of dates", len(book_model.category.dates))
                print(f"Book :: {book_model.book_title} :: Total number of events", len(book_model.category.events))
                print(f"Book :: {book_model.book_title} :: Generated number of questions: ",
                      book_model.count_questions())


if __name__ == "__main__":
    main()
